/************************************************************************************

Filename    :   Logging_Tools.h
Content     :   Tools for Logging
Created     :   Oct 26, 2015
Authors     :   Chris Taylor

Copyright   :   Copyright (c) Facebook Technologies, LLC and its affiliates. All rights reserved.

Licensed under the Oculus Master SDK License Version 1.0 (the "License");
you may not use the Oculus VR Rift SDK except in compliance with the License,
which is provided at the time of installation or download, or which
otherwise accompanies this software in either electronic or hard copy form.

You may obtain a copy of the License at

https://developer.oculus.com/licenses/oculusmastersdk-1.0

Unless required by applicable law or agreed to in writing, the Oculus VR SDK
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

************************************************************************************/

#ifndef Logging_Tools_h
#define Logging_Tools_h

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4265) // disable the virtual destructor warning generated by <mutex>
#endif

#include <string>

//-----------------------------------------------------------------------------
// Platform-specific macros

#ifdef _MSC_VER
#define LOGGING_INLINE __forceinline
#else
#define LOGGING_INLINE inline
#endif

#if defined(_DEBUG) || defined(DEBUG)
#define LOGGING_DEBUG
#endif

#define LOGGING_STRINGIZEIMPL(x) #x
#define LOGGING_STRINGIZE(x) LOGGING_STRINGIZEIMPL(x)

#if defined(_WIN32)
// It is common practice to define WIN32_LEAN_AND_MEAN to reduce compile times.
// However this then requires us to define our own NTSTATUS data type and other
// irritations throughout our code-base.
#ifndef WIN32_LEAN_AND_MEAN
//#define WIN32_LEAN_AND_MEAN
#endif

// Prevents <Windows.h> from #including <Winsock.h>, as we use <Winsock2.h> instead.
#ifndef _WINSOCKAPI_
#define DID_DEFINE_WINSOCKAPI
#define _WINSOCKAPI_
#endif

// Prevents <Windows.h> from defining min() and max() macro symbols.
#ifndef NOMINMAX
#define NOMINMAX
#endif

#define WIN
#include <windows.h>
#endif

// Work around some broken Windows headers:
#ifdef DID_DEFINE_WINSOCKAPI
#undef _WINSOCKAPI_
#undef DID_DEFINE_WINSOCKAPI
#endif

#if defined(LOGGING_DEBUG)
#if defined(_MSC_VER)
#include <intrin.h>
#define LOGGING_DEBUG_BREAK() __debugbreak()
#else
#define LOGGING_DEBUG_BREAK() \
  { __asm__("int $3\n" : :); }
#endif
#else
#define LOGGING_DEBUG_BREAK()
#endif

#include <atomic>
#include <mutex>

namespace ovrlog {

#if defined(_WIN32)
typedef HANDLE OvrLogHandle;
#endif // defined(_WIN32)

//-----------------------------------------------------------------------------
// Lock
//
// Critical section wrapper.
//
class Lock {
 public:
  Lock();
  ~Lock();

  // Returns true if lock could be held.
  bool TryEnter();

  void Enter();
  void Leave();

 private:
#if defined(_WIN32)
  // Until the behavior of std::recursive_mutex is vetted, we use CRITICAL_SECTION on Windows.
  CRITICAL_SECTION cs;
#else
  std::recursive_mutex m;
#endif
};

//-----------------------------------------------------------------------------
// Locker
//
// Scoped lock wrapper.
// To do: Replace this class with direct std::lock usage.
//
class Locker {
 public:
  Locker(Lock* lock = nullptr);
  Locker(Lock& lock);
  ~Locker();

  // Returns true if lock could be held.
  bool TrySet(Lock* lock);
  bool TrySet(Lock& lock);

  // Lock the given lock.  Unlocks previously held lock.
  void Set(Lock* lock);
  void Set(Lock& lock);

  // Unlock any previously held lock.
  void Clear();

 private:
  Lock* TheLock;
};

#if defined(_WIN32)
//-----------------------------------------------------------------------------
// AutoHandle
//
// Auto-close wrapper for a HANDLE that is invalid when NULL.
// For example, ::OpenProcess() returns NULL on failure.
class AutoHandle {
 public:
  AutoHandle(OvrLogHandle handle = nullptr);
  ~AutoHandle();

  void operator=(OvrLogHandle handle);

  OvrLogHandle Get() const {
    return TheHandle;
  }

  bool IsValid() const {
    return TheHandle != nullptr;
  }

  void Clear();

 protected:
  OvrLogHandle TheHandle;
};

//-----------------------------------------------------------------------------
// Terminator
//
// Helper class that allows for signaled exits to an infinite event wait.
// The main purpose is the WaitOn() function.
class Terminator {
 public:
  Terminator();
  ~Terminator();

  bool IsTerminated() const {
    return Terminated;
  }

  // Setup
  bool Initialize();

  // Flag terminated
  void Terminate();

  // Returns true if the event signaled and false on termination or timeout.
  // Call IsTerminated() to differentiate termination from timeout.
  // Passing INFINITE for timeout will only return false on termination.
  bool WaitOn(OvrLogHandle hEvent, uint32_t timeoutMsec = INFINITE);

  // Returns true if the sleep interval exceeded or false on termination.
  bool WaitSleep(int milliseconds);

 private:
  // Should we terminate?
  std::atomic<bool> Terminated;

  // Event to wake up during waits
  AutoHandle TerminateEvent;
};
#endif // defined(_WIN32)

//-----------------------------------------------------------------------------
// Tools

bool IsDebuggerAttached();

} // namespace ovrlog

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif // Logging_Tools_h
